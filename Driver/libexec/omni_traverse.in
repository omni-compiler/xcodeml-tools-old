#!/bin/bash
#
# V3
#

#VERBOSE=yes
MODE=1         # generate subroutines respectively for all groups
#MODE=2          # generate one subroutine for all proceures of all groups

#========== not needed due to the new logic
##-- for MODE 1
#DEFAULT_F_GROUPNAMES=( xmpf_traverse_module xmpf_traverse_initcoarray )
#DEFAULT_C_GROUPNAMES=( xmpc_traverse_init xmpc_traverse_finalize )
#==========

NM="@NM@"

USAGE='usage: '$0' <option> ... <input_file> ...
  <option>
    --help               this help
    --verbose            verbose mode
    --F | --C            which language (necessary)
    --prefix <prefix>    prefix characters of the target procecdure names, such as xmpf and xmpc
    -o <output_file>     name of the output file (*.f90 or *.c file is expected)
  <input_file>           input file name (.o and .a files are expected)
'

#--------------------------------------------------------------
# option analysis
#--------------------------------------------------------------
INFILES=()
while [ -n "$1" ]; do
    case "$1" in
    --help)     HELP=yes;;
    --verbose)  VERBOSE=yes;;
    --F)        LANG=F;;
    --C)        LANG=C;;
    --prefix)   shift; PREFIX="$1";;
    -o)         shift; OUTFILE="$1";;
    *.o)        INFILES+=("$1");;
    *.a)        INFILES+=("$1");;
    *)          echo "$0: illegal filename $1" 1>&2; HELP=yes;;
    esac
    shift
done

if [ "$HELP" = "yes" -o "$LANG" = "" ]; then
   echo $USAGE 1>&2
   exit 1
fi

if [ "$VERBOSE" = "yes" ]; then
   echo ---------------------------
   echo NM=$NM
   echo HELP=$HELP
   echo VERBOSE=$VERBOSE
   echo LANG=$LANG
   echo PREFIX=$PREFIX
   echo INFILES=${INFILES[@]}
   echo OUTFILE=$OUTFILE
   echo ---------------------------
fi


#--------------------------------------------------------------
# find names ${PREFIX}_traverse_* 
#--------------------------------------------------------------

#--- get traverse procedures
candidates=`$NM "${INFILES[@]}" | awk 'NF >= 2 && $(NF-1) == "U" { print $NF }'`
traversers=()
for name in $candidates; do
    case $name in
        ${PREFIX}_traverse_?*)
        case "$LANG" in 
            F) traversers+=( ${name%_} );;    # omit the last '_'
            C) traversers+=( $name );;
        esac;;
    esac
done

#--- get procedures to be traversed
candidates=`$NM "${INFILES[@]}" | awk 'NF >= 2 && $(NF-1) == "T" { print $NF }'`
procedures=()
for name in $candidates; do
    case $name in
        ${PREFIX}_traverse_*_?* )
            case "$LANG" in
                F) procedures+=( ${name%_} );;    # get name from "name_"
                C) procedures+=( $name );;
            esac;;
        ${PREFIX}_traverse_* )
            echo found unacceptable name of traverse procedure: \"${name}\"
            error=yes;;
    esac
done
if [ "${error}" = "yes" ]; then
    exit 1
fi

#--- classify the chosen names by keywords
if [ $MODE == 1 ]; then
    groupnames=( ${traversers[@]} )
else
  groupnames=()
  for name in "${procedures[@]}"; do
    # separate procedure name "prefix_travserse_keywd_reststring"
    # into three parts, groupname, '_' and basename, where
    #  groupname is "prefix_travserse_keywd" and
    #  basename is any string possibly including '_'
    basename=${name#${PREFIX}_*_*_}
    groupname=${name%_${basename}}

    # append part1 to keystrings if not appended yet
    case "${groupnames[*]}" in
        $groupname)  ;;
        *)           groupnames+=( $groupname );;
    esac
  done
fi

if [ "$VERBOSE" = "yes" ]; then
    echo ------------
    echo "candidates="$candidates
    echo "procedures=${procedures[@]}"
    echo "groupnames=${groupnames[@]}"
    echo ------------
fi

#--------------------------------------------------------------
# file output
#--------------------------------------------------------------

fortran_output_MODE1() {
    for groupname in "${groupnames[@]}"; do
        echo "subroutine ${groupname}"
        for name in "${procedures[@]}"; do
            if [[ ${name} =~ ${groupname}_* ]]; then
                echo "  call ${name}"
            fi
        done
        echo "end subroutine"
        echo
    done
}

fortran_output_MODE2() {
    echo "subroutine ${PREFIX}_traverse"
        for name in "${procedures[@]}"; do
            echo "  call ${name}"
        done
    echo "end subroutine"
}

c_output_MODE1() {
    for groupname in "${groupnames[@]}"; do
        echo "extern void ${groupname}(void);"
    done
    echo

    for groupname in "${groupnames[@]}"; do
        echo "void ${groupname}() {"
        for name in "${procedures[@]}"; do
            if [[ ${name} =~ ${groupname}_* ]]; then
                echo "  ${name}();"
            fi
        done
        echo "}"
        echo
    done
}

c_output_MODE2() {
    for groupname in "${groupnames[@]}"; do
        echo "extern void ${groupname}(void);"
    done
    echo

    echo "void ${PREFIX}_traverse()"
    echo "{"
        for name in "${procedures[@]}"; do
            echo "  ${name}();"
        done
    echo "}"
}

file_output() {
    case $MODE in
    1)  case "$LANG" in
        F) fortran_output_MODE1;;
        C) c_output_MODE1;;
        esac;;
    2)  case "$LANG" in
        F) fortran_output_MODE2;;
        C) c_output_MODE2;;
        esac;;
    esac
}    

if [ "$VERBOSE" = "yes" ]; then
    echo ---------------------------------------------- output $OUTFILE
    file_output
    echo ------------------------------------------ end output $OUTFILE
fi

if [ -z "$OUTFILE" ]; then
    file_output
else
    file_output > $OUTFILE
fi

exit 0


